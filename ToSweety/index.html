<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å°èƒ†å®è´ç”Ÿæ—¥å¿«ä¹ - ç²’å­äº‘</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #E6E6FA, #B0E0E6); /* æ·¡ç´« + å¥¶è“ */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .camera-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            transform: scaleX(-1); /* é•œåƒ */
            opacity: 0.7;
            transition: opacity 1s ease, border 1s ease; /* å¢åŠ é€æ˜åº¦å’Œè¾¹æ¡†çš„è¿‡æ¸¡æ•ˆæœ */
            z-index: 20;
            background: #000;
        }

        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 240, 245, 1);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s ease;
            flex-direction: column;
        }
        
        .loading-text {
            color: #9370DB;
            font-size: 24px;
            font-weight: bold;
            margin-top: 20px;
        }

        /* ç®€å•çš„åŠ è½½åŠ¨ç”» */
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #E6E6FA;
            border-top: 5px solid #9370DB;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .control-panel {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 15px;
            color: #483D8B;
            max-width: 300px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 10px 0;
            text-shadow: 0 0 5px rgba(255,255,255,0.8);
        }

        .instructions {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .upload-btn {
            margin-top: 10px;
            background: linear-gradient(45deg, #FFB6C1, #9370DB);
            border: none;
            padding: 10px 20px;
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
            pointer-events: auto;
            display: inline-block;
        }

        .upload-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px #FFB6C1;
        }
        
        .status-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 20px;
            color: #6A5ACD;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 2px 10px rgba(147, 112, 219, 0.3);
            transition: background 0.5s, color 0.5s; /* å¢åŠ èƒŒæ™¯å’Œæ–‡å­—é¢œè‰²çš„è¿‡æ¸¡æ•ˆæœ */
        }

        #file-input { display: none; }
    </style>
    <!-- Import Maps for Three.js and MediaPipe -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loading" class="loading-screen">
        <div class="spinner"></div>
        <div class="loading-text">æ­£åœ¨æº–å‚™ç”Ÿæ—¥é©šå–œ...</div>
        <div style="margin-top:10px; font-size: 0.8em; color: #666;">è«‹å…è¨±é¡é ­æ¬Šé™ä»¥é–‹å•Ÿé­”æ³•äº’å‹•</div>
    </div>

    <div id="ui-layer">
        <div class="control-panel">
            <h1>âœ¨ é­”æ³•æ‰‹å‹¢æ§åˆ¶ âœ¨</h1>
            <div id="instruction-text" class="instructions">
                âœŠ <b>æ¡æ‹³</b>ï¼šå‡èšå›æ†¶ (åˆæ”)<br>
                ğŸ– <b>å¼µé–‹æ‰‹</b>ï¼šé‡‹æ”¾å¿«æ¨‚ (æ•£é–‹)<br>
                ğŸ‘‹ <b>ç§»å‹•æ‰‹æŒ</b>ï¼šåœ¨æ•£é–‹æ™‚æ—‹è½‰è¦–è§’<br>
                ğŸ‘Œ <b>æåˆ</b>ï¼šæŠ“å–ä¸€å¼µç…§ç‰‡æ”¾å¤§
            </div>
            <button class="upload-btn" onclick="document.getElementById('file-input').click()">ğŸ“¸ ä¸Šå‚³ç…§ç‰‡ç”Ÿæˆé›²åœ˜</button>
            <input type="file" id="file-input" multiple accept="image/*">
        </div>
        <div id="status-text" class="status-badge">ç­‰å¾…æ‰‹å‹¢...</div>
    </div>

    <video id="webcam" class="camera-feed" autoplay playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, GestureRecognizer } from '@mediapipe/tasks-vision';

        // --- é…ç½® ---
        const CONFIG = {
            particleCount: 250,  // ç¸½ç²’å­æ•¸
            scatterRadius: 30,   // æ•£é–‹ç¯„åœ
            sphereRadius: 8,     // èšåˆçƒé«”åŠå¾‘
            colors: [0xFFB6C1, 0x9370DB, 0x87CEEB, 0xFFFFFF, 0xFF69B4], // ç²‰ã€ç´«ã€è—ã€ç™½ã€æ·±ç²‰
            icons: ['ğŸ‚', 'ğŸ•¯ï¸', 'ğŸ¾', 'ğŸ€', 'ğŸ©'],
            catText: "å°è†½å¯¶è²ç”Ÿæ—¥å¿«æ¨‚"
        };
        // æ¨™èªç‰Œçš„é»˜èªä½ç½®å’Œæ•£é–‹ä½ç½®
        const SIGN_POS_COALESCED = { y: 15, z: 5 };
        const SIGN_POS_DISPERSED = { y: 20, z: 8 };

        // --- å…¨åŸŸç‹€æ…‹ ---
        let scene, camera, renderer, composer;
        let particles = [];
        let photoTextures = [];     // ç”¨æˆ¶ä¸Šå‚³çš„ç…§ç‰‡ç´‹ç†
        let defaultTextures = [];   // é»˜èªåœ–ç¤ºç´‹ç†
        let balloonGroup, petalGroup;
        let catSignMesh;
        
        let gestureRecognizer;
        let videoElement = document.getElementById('webcam');
        let lastVideoTime = -1;
        let results = undefined;
        let mediaPipeFailed = false; // æ–°å¢ï¼šç”¨æ–¼æ¨™è¨˜ MediaPipe æ˜¯å¦è¼‰å…¥å¤±æ•—

        // äº’å‹•ç‹€æ…‹
        const STATE = {
            COALESCED: 'COALESCED',
            DISPERSED: 'DISPERSED',
            ZOOM: 'ZOOM'
        };
        let currentState = STATE.COALESCED;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let zoomedParticleIndex = -1;

        // --- åˆå§‹åŒ– ---

        async function init() {
            // 1. Three.js è¨­å®š
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // éœ§æ•ˆï¼Œå¢å¼·æ·±é‚ƒæ„Ÿ
            scene.fog = new THREE.FogExp2(0xE6E6FA, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 40;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // æ¸›å°‘æ›å…‰åº¦ï¼Œæå‡æ•´é«”å°æ¯”åº¦
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; // å¾ 1.2 é™ä½åˆ° 1.0

            container.appendChild(renderer.domElement);

            // å¾ŒæœŸè™•ç† (Bloom è¼å…‰)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            // é™ä½è¼å…‰å¼·åº¦ï¼Œæ¸›å°‘ç•«é¢æ´—ç™½
            bloomPass.strength = 0.7; // å¾ 0.9 é™ä½åˆ° 0.7 
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç‡ˆå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xFFB6C1, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // 2. è³‡æºç”Ÿæˆ
            generateTextures();
            createParticles();
            createDecorations(); // æ°£çƒå’ŒèŠ±ç“£
            createCatSign(); // å·²æ›´æ–°ç‚ºå¸ƒå¶è²“å½¢è±¡

            // 3. MediaPipe è¨­å®š (éåŒæ­¥ï¼Œå¯èƒ½å¤±æ•—)
            await setupMediaPipe();

            // 4. ç›£è½å™¨
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            
            // 5. å•Ÿå‹•å¾ªç’°
            animate();
            
            // å¦‚æœ MediaPipe å¤±æ•—ï¼Œç›´æ¥ç§»é™¤è¼‰å…¥ç•«é¢ï¼Œè®“å‹•ç•«å•Ÿå‹•
            if (mediaPipeFailed) {
                 document.getElementById('loading').style.opacity = 0;
                 setTimeout(() => document.getElementById('loading').remove(), 1000);
            }
        }

        // --- è³‡æºç”Ÿæˆè¼”åŠ©å‡½å¼ ---

        function generateTextures() {
            // ç”Ÿæˆ Emoji ç´‹ç†
            CONFIG.icons.forEach(icon => {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.font = '80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText(icon, 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                defaultTextures.push(texture);
            });

            // ç”Ÿæˆã€Œä½”ä½ç¬¦ã€ç…§ç‰‡ç´‹ç†
            const pCanvas = document.createElement('canvas');
            pCanvas.width = 256;
            pCanvas.height = 300;
            const ctx = pCanvas.getContext('2d');
            ctx.fillStyle = '#FFF';
            ctx.fillRect(0,0,256,300);
            ctx.fillStyle = '#EEE';
            ctx.fillRect(10,10,236,236);
            ctx.fillStyle = '#333';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ä¸Šå‚³ç…§ç‰‡', 128, 150);
            
            const pTexture = new THREE.CanvasTexture(pCanvas);
            photoTextures.push(pTexture); // é»˜èªä½”ä½åœ–
        }

        function createParticles() {
            // å¢åŠ ç²’å­åŸºç¤å°ºå¯¸
            const geometry = new THREE.PlaneGeometry(2.5, 2.5); 
            const group = new THREE.Group();
            scene.add(group);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const isPhoto = Math.random() > 0.6;
                
                let material;
                if (isPhoto) {
                    const initialMap = photoTextures.length > 0 ? photoTextures[0] : defaultTextures[0];
                    material = new THREE.MeshBasicMaterial({ 
                        map: initialMap, 
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                } else {
                    const texIndex = Math.floor(Math.random() * defaultTextures.length);
                    material = new THREE.MeshBasicMaterial({ 
                        map: defaultTextures[texIndex], 
                        transparent: true,
                        color: CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)],
                        side: THREE.DoubleSide
                    });
                }

                const mesh = new THREE.Mesh(geometry, material);
                
                // è®“ç…§ç‰‡ç²’å­ç¨å¾®å¤§ä¸€é»
                if (isPhoto) {
                    mesh.scale.set(1.2, 1.2, 1.2); 
                }

                // çƒå½¢åæ¨™ç”¨æ–¼èšåˆç‹€æ…‹
                const phi = Math.acos(-1 + (2 * i) / CONFIG.particleCount);
                const theta = Math.sqrt(CONFIG.particleCount * Math.PI) * phi;
                
                const r = CONFIG.sphereRadius + (Math.random() - 0.5) * 2;
                const x = r * Math.cos(theta) * Math.sin(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(phi);

                mesh.position.set(x, y, z);
                mesh.lookAt(0,0,0);

                // å„²å­˜ä¸­ç¹¼è³‡æ–™ç”¨æ–¼å‹•ç•«
                mesh.userData = {
                    originalPos: new THREE.Vector3(x, y, z),
                    scatterPos: new THREE.Vector3(
                        (Math.random() - 0.5) * CONFIG.scatterRadius * 2,
                        (Math.random() - 0.5) * CONFIG.scatterRadius * 1.5,
                        (Math.random() - 0.5) * CONFIG.scatterRadius * 1.5
                    ),
                    velocity: new THREE.Vector3(0, Math.random() * 0.02, 0),
                    rotationSpeed: new THREE.Vector3(Math.random()*0.01, Math.random()*0.01, 0),
                    isPhoto: isPhoto,
                    id: i
                };

                particles.push(mesh);
                group.add(mesh);
            }
        }

        function createCatSign() {
            // å‰µå»ºæ¨™èªç‰Œ
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 1. ç•«èƒŒæ™¯ (æŸ”å’Œå…‰æšˆ)
            const grad = ctx.createRadialGradient(256, 256, 50, 256, 256, 250);
            grad.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 512, 512);

            // 2. ç•«å¸ƒå¶è²“ (Ragdoll style)
            ctx.save();
            ctx.translate(256, 220);

            // èº«é«”/é ­éƒ¨ - å¥¶æ²¹è‰² (Ragdoll body)
            ctx.fillStyle = '#FFF5E1'; 
            ctx.beginPath(); 
            ctx.arc(0, 0, 80, 0, Math.PI * 2); 
            ctx.fill();

            // å°–ç«¯é» - æ£•è‰² (Points: ears, muzzle area)
            ctx.fillStyle = '#A0522D'; // ä¸­æ£•è‰²
            // å°–å°–çš„è€³æœµ
            ctx.beginPath(); ctx.moveTo(-60, -80); ctx.lineTo(-90, -120); ctx.lineTo(-30, -80); ctx.fill();
            ctx.beginPath(); ctx.moveTo(60, -80); ctx.lineTo(90, -120); ctx.lineTo(30, -80); ctx.fill();
            // é¢éƒ¨ V å½¢é»
            ctx.beginPath(); ctx.arc(0, 10, 50, 0, Math.PI); ctx.fill();
            
            // çœ¼ç› - å¸ƒå¶è²“æ¨™èªŒæ€§çš„è—çœ¼
            ctx.fillStyle = '#ADD8E6'; // æ·ºè—è‰²
            ctx.beginPath(); ctx.arc(-30, -20, 15, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(30, -20, 15, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#00008B'; // æ·±è—è‰²ç³å­”
            ctx.beginPath(); ctx.arc(-30, -20, 5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(30, -20, 5, 0, Math.PI*2); ctx.fill();

            // é¼»å­å’Œå˜´å·´ (ç²‰è‰²)
            ctx.fillStyle = 'pink';
            ctx.beginPath(); ctx.arc(0, 10, 8, 0, Math.PI*2); ctx.fill();
            
            // é¬é¬š
            ctx.strokeStyle = '#555'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0, 18); ctx.lineTo(-50, 10); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, 18); ctx.lineTo(50, 10); ctx.stroke();
            ctx.restore();


            // 3. ç•«ç‰Œå­
            ctx.strokeStyle = '#A0522D'; // æ£•è‰²æ”¯æ¶
            ctx.lineWidth = 5;
            ctx.beginPath(); ctx.moveTo(256, 300); ctx.lineTo(256, 450); ctx.stroke(); // ç‰Œå­æ”¯æ¶å±…ä¸­

            ctx.fillStyle = '#F08080'; // æŸ”å’Œç´…è‰²/çŠç‘šè‰²ä½œç‚ºèƒŒæ™¯ï¼Œå¢å¼·æ–‡å­—å°æ¯”
            ctx.strokeStyle = '#FFFFFF'; 
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.roundRect(100, 300, 312, 100, 20);
            ctx.fill(); ctx.stroke();

            // 4. æ–‡æœ¬ (å¯æ„›å­—é«” + æé‚Š/é™°å½±)
            ctx.fillStyle = '#FFFFFF'; // ç™½è‰²æ–‡å­—
            ctx.strokeStyle = '#A0522D'; // æ£•è‰²æé‚Š
            ctx.lineWidth = 2;
            // ä½¿ç”¨å¯æ„›é¢¨æ ¼çš„å­—é«”
            ctx.font = 'bold 40px "Comic Sans MS", "Microsoft YaHei", sans-serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = "rgba(0,0,0,0.5)"; // å¢åŠ é™°å½±å¼·åº¦
            ctx.shadowBlur = 5;
            
            // å…ˆç¹ªè£½æé‚Šï¼Œå¾Œç¹ªè£½å¡«å……ï¼Œç¢ºä¿æ–‡å­—æ¸…æ™°
            ctx.strokeText(CONFIG.catText, 256, 350); 
            ctx.fillText(CONFIG.catText, 256, 350);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            catSignMesh = new THREE.Sprite(material);
            catSignMesh.scale.set(15, 15, 1); 
            catSignMesh.position.set(0, SIGN_POS_COALESCED.y, SIGN_POS_COALESCED.z); 
            scene.add(catSignMesh);
        }

        function createDecorations() {
            // å‰µå»ºæ°£çƒå’ŒèŠ±ç“£ (çœç•¥ï¼Œèˆ‡ä¸Šæ¬¡ç›¸åŒ)
            balloonGroup = new THREE.Group();
            const balloonGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const balloonMat = new THREE.MeshPhongMaterial({ 
                color: 0xFF69B4, shininess: 100, specular: 0xFFFFFF 
            });
            
            for(let i=0; i<15; i++) {
                const b = new THREE.Mesh(balloonGeo, balloonMat);
                b.position.set((Math.random()-0.5)*40, -20 + Math.random()*20, (Math.random()-0.5)*20);
                b.userData = { speed: 0.02 + Math.random()*0.03 };
                balloonGroup.add(b);
            }
            scene.add(balloonGroup);

            petalGroup = new THREE.Group();
            const petalGeo = new THREE.PlaneGeometry(0.5, 0.5); 
            const petalMat = new THREE.MeshBasicMaterial({ 
                color: 0xFFB7C5, side: THREE.DoubleSide, transparent: true, opacity: 0.8 
            });

            for(let i=0; i<100; i++) {
                const p = new THREE.Mesh(petalGeo, petalMat);
                p.position.set((Math.random()-0.5)*50, Math.random()*30, (Math.random()-0.5)*30);
                p.rotation.set(Math.random(), Math.random(), Math.random());
                p.userData = { 
                    fallSpeed: 0.02 + Math.random()*0.05,
                    rotSpeed: 0.02 + Math.random()*0.02
                };
                petalGroup.add(p);
            }
            scene.add(petalGroup);
        }

        function handleImageUpload(event) {
            const files = event.target.files;
            if (!files.length) return;

            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 512;
                        canvas.height = 512;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0,0,512,512);
                        
                        const scale = Math.min(460/img.width, 460/img.height);
                        const w = img.width * scale;
                        const h = img.height * scale;
                        // åœ¨ç™½è‰²èƒŒæ™¯ä¸Šç¹ªè£½åœ–ç‰‡ï¼Œä»¥ç¢ºä¿è¶³å¤ çš„å°æ¯”åº¦
                        ctx.drawImage(img, (512-w)/2, 26, w, h);
                        
                        const tex = new THREE.CanvasTexture(canvas);
                        photoTextures.push(tex);
                        
                        updateParticlesWithPhotos();
                    };
                };
                reader.readAsDataURL(file);
            });
        }

        function updateParticlesWithPhotos() {
            if (photoTextures.length <= 1) return;
            
            let texIndex = 1;
            particles.forEach(p => {
                if (p.userData.isPhoto) {
                    p.material.map = photoTextures[texIndex];
                    p.material.needsUpdate = true;
                    texIndex = (texIndex + 1) % photoTextures.length;
                    if (texIndex === 0) texIndex = 1; 
                }
            });
        }

        // --- MediaPipe é‚è¼¯ ---

        async function setupMediaPipe() {
            // **æ³¨æ„ï¼šå°‡ä¸‹é¢çš„ 'gesture_recognizer.task' è¦–ç‚ºç›¸å°æ–¼æ­¤ HTML æ–‡ä»¶çš„æœ¬åœ°è·¯å¾‘ã€‚**
            // **æ‚¨éœ€è¦å°‡æª”æ¡ˆä¸‹è¼‰åˆ°èˆ‡æ­¤ HTML æ–‡ä»¶ç›¸åŒçš„è³‡æ–™å¤¾æ‰èƒ½é›¢ç·šé‹è¡Œã€‚**
            const MODEL_PATH = 'gesture_recognizer.task'; 
            let stream;
            
            try {
                // 1. åˆå§‹åŒ–æ‰‹å‹¢è­˜åˆ¥å™¨
                document.getElementById('status-text').innerText = "è¼‰å…¥ AI æ¨¡å‹...";
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: MODEL_PATH, // <--- ä½¿ç”¨æœ¬åœ°è·¯å¾‘
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                document.getElementById('status-text').innerText = "è«‹æ±‚é¡é ­æ¬Šé™...";

                // 2. å•Ÿå‹•é¡é ­
                const constraints = { video: { width: 320, height: 240 } };
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    document.getElementById('status-text').innerText = "å·²å°±ç·’ï¼Œè«‹ä¼¸å‡ºæ‰‹";
                    // ç§»é™¤è¼‰å…¥ç•«é¢
                    document.getElementById('loading').style.opacity = 0;
                    setTimeout(() => document.getElementById('loading').remove(), 1000);

                    // é–‹å§‹é æ¸¬å¾ªç’°
                    predictWebcam();
                };

            } catch (error) {
                console.error("MediaPipe or Camera setup failed:", error);
                
                let errorMessage = "åˆå§‹åŒ–å¤±æ•—ï¼š";
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage = "é¡é ­æ¬Šé™è¢«æ‹’ã€‚æ‰‹å‹¢äº’å‹•ç¦ç”¨ (å•Ÿç”¨è‡ªå‹•æ—‹è½‰)ã€‚";
                    document.getElementById('instruction-text').innerHTML = "<b>ğŸ‘‹ æ‰‹å‹¢äº’å‹•å·²ç¦ç”¨ã€‚</b><br>æ­£åœ¨å•Ÿç”¨è‡ªå‹•æ—‹è½‰æ¨¡å¼ã€‚";
                } else if (error.name === 'NotFoundError') {
                    errorMessage = "æœªæ‰¾åˆ°é¡é ­è¨­å‚™ã€‚æ‰‹å‹¢äº’å‹•ç¦ç”¨ (å•Ÿç”¨è‡ªå‹•æ—‹è½‰)ã€‚";
                    document.getElementById('instruction-text').innerHTML = "<b>ğŸ‘‹ æ‰‹å‹¢äº’å‹•å·²ç¦ç”¨ã€‚</b><br>æ­£åœ¨å•Ÿç”¨è‡ªå‹•æ—‹è½‰æ¨¡å¼ã€‚";
                } else {
                    // ç¶²è·¯è¼‰å…¥å¤±æ•—æˆ–å…¶ä»–æœªçŸ¥éŒ¯èª¤æœƒé€²å…¥æ­¤è™•ï¼Œé€šå¸¸æ˜¯æ¨¡å‹æª”æ¡ˆæœªæ‰¾åˆ°æˆ–è¼‰å…¥å¤±æ•—
                    errorMessage = `AI æ¨¡å‹è¼‰å…¥å¤±æ•— (${MODEL_PATH})ï¼Œæ‰‹å‹¢äº’å‹•ç¦ç”¨ (å•Ÿç”¨è‡ªå‹•æ—‹è½‰)ã€‚`;
                    document.getElementById('instruction-text').innerHTML = "<b>ğŸ‘‹ AI æ¨¡å‹è¼‰å…¥å¤±æ•—ã€‚</b><br>è«‹æª¢æŸ¥ç¶²è·¯æˆ–ç¢ºä¿ `gesture_recognizer.task` æª”æ¡ˆå­˜åœ¨æ–¼åŒè³‡æ–™å¤¾ã€‚";
                }
                
                document.getElementById('status-text').innerText = errorMessage;
                videoElement.style.opacity = 0.2; 
                videoElement.style.border = '2px solid red';
                
                mediaPipeFailed = true; // æ¨™è¨˜ç‚ºå¤±æ•—
                
                // å¦‚æœå¤±æ•—ï¼Œä¹Ÿç§»é™¤è¼‰å…¥ç•«é¢ï¼Œé¿å…å¡æ­»
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => document.getElementById('loading').remove(), 1000);
            }
        }

        async function predictWebcam() {
            if (mediaPipeFailed) return; // å¦‚æœå¤±æ•—ï¼Œå‰‡ä¸é€²è¡Œé æ¸¬

            if (lastVideoTime === -1) {
                 videoElement.style.opacity = 0;
                 document.getElementById('status-text').style.background = 'rgba(147, 112, 219, 0.8)'; 
                 document.getElementById('status-text').style.color = 'white';
            }
            
            if (gestureRecognizer && videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                try {
                    results = gestureRecognizer.recognizeForVideo(videoElement, Date.now());
                    processGestures(results);
                } catch (e) {
                    console.warn("Gesture recognition skipped for this frame", e);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(results) {
            // ... (æ‰‹å‹¢è™•ç†é‚è¼¯ï¼Œèˆ‡ä¸Šæ¬¡ç›¸åŒ) ...
            if (!results || !results.gestures || results.gestures.length === 0 || !results.landmarks || results.landmarks.length === 0) {
                document.getElementById('status-text').innerText = "æœªæª¢æ¸¬åˆ°æ‰‹";
                return;
            }

            const gesturesList = results.gestures[0];
            const landmarksList = results.landmarks[0];
            
            if (!gesturesList || gesturesList.length === 0 || !landmarksList) {
                document.getElementById('status-text').innerText = "æª¢æ¸¬ä¸­...";
                return;
            }

            const gesture = gesturesList[0].categoryName;
            const landmarks = landmarksList;
            
            let status = "ç­‰å¾…...";

            if (gesture === 'Closed_Fist') {
                status = "å‹•ä½œ: èšåˆ (æ¡æ‹³)";
                changeState(STATE.COALESCED);
            } else if (gesture === 'Open_Palm') {
                status = "å‹•ä½œ: æ•£é–‹ (å¼µæ‰‹)";
                changeState(STATE.DISPERSED);
            } else if (gesture === 'Victory' || isPinching(landmarks)) {
                if (currentState === STATE.DISPERSED) {
                    status = "å‹•ä½œ: æŠ“å–ç…§ç‰‡ (æåˆ)";
                    if (currentState !== STATE.ZOOM) {
                        changeState(STATE.ZOOM);
                    }
                }
            }
            
            if (currentState === STATE.DISPERSED && gesture !== 'Closed_Fist') {
                if (landmarks[0]) {
                    const x = landmarks[0].x;
                    const y = landmarks[0].y;
                    
                    targetRotationY = (x - 0.5) * 4;
                    targetRotationX = (y - 0.5) * 2;
                    status += " | æ—‹è½‰ä¸­";
                }
            }

            document.getElementById('status-text').innerText = status;
        }

        function isPinching(landmarks) {
            if (!landmarks[4] || !landmarks[8]) return false;
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            return dist < 0.05; 
        }

        // --- ç‹€æ…‹ç®¡ç†èˆ‡å‹•ç•« (çœç•¥éƒ¨åˆ†ï¼Œæ ¸å¿ƒé‚è¼¯ç›¸åŒ) ---

        function changeState(newState) {
            if (currentState === newState) return;
            
            // ... (ç‹€æ…‹åˆ‡æ›é‚è¼¯ï¼Œèˆ‡ä¸Šæ¬¡ç›¸åŒ) ...
            
            currentState = newState;

            if (newState === STATE.COALESCED) {
                particles.forEach(p => {
                    new TWEEN.Tween(p.position).to(p.userData.originalPos, 1500).easing(TWEEN.Easing.Elastic.Out).start();
                    new TWEEN.Tween(p.rotation).to({ x: 0, y: 0, z: 0 }, 1500).onUpdate(() => p.lookAt(0,0,0)).start();
                });
                new TWEEN.Tween(catSignMesh.position).to(SIGN_POS_COALESCED, 1000).start();

            } else if (newState === STATE.DISPERSED) {
                particles.forEach(p => {
                    new TWEEN.Tween(p.position).to(p.userData.scatterPos, 1500).easing(TWEEN.Easing.Back.Out).start();
                    new TWEEN.Tween(p.rotation).to({ x: camera.rotation.x, y: camera.rotation.y, z: 0 }, 1000).onUpdate(() => p.lookAt(camera.position)).start();
                });
                new TWEEN.Tween(catSignMesh.position).to(SIGN_POS_DISPERSED, 1000).start();

            } else if (newState === STATE.ZOOM) {
                const photoParticles = particles.filter((p, i) => p.userData.isPhoto);
                if (photoTextures.length > 1 && photoParticles.length > 0) {
                    const target = photoParticles[Math.floor(Math.random() * photoParticles.length)];
                    zoomedParticleIndex = particles.indexOf(target);

                    new TWEEN.Tween(target.position).to({ x: 0, y: 0, z: 25 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
                    new TWEEN.Tween(target.scale).to({ x: 5, y: 5, z: 5 }, 1000).start();
                    
                    particles.forEach(p => {
                        if (p !== target) {
                            new TWEEN.Tween(p.position.z).to(p.userData.scatterPos.z - 5, 1000).start();
                        }
                    });
                } else {
                    console.log("æ²’æœ‰ç…§ç‰‡å¯æ”¾å¤§ï¼Œè¿”å›æ•£é–‹ç‹€æ…‹ã€‚");
                    currentState = STATE.DISPERSED; 
                }
            }
        }

        // --- ä¸»å¾ªç’° ---

        const clock = new THREE.Clock();

        function animate(time) {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            TWEEN.update(time);

            // 1. å ´æ™¯æ—‹è½‰é‚è¼¯
            if (mediaPipeFailed) {
                // å¦‚æœ MediaPipe å¤±æ•—ï¼Œå‰‡å•Ÿç”¨è‡ªå‹•æ—‹è½‰ï¼ˆå„ªé›…é™ç´šï¼‰
                scene.rotation.y += 0.003;
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, Math.sin(time * 0.0001) * 0.1, 0.05);

            } else if (currentState === STATE.COALESCED) {
                // èšåˆç‹€æ…‹ï¼šæ…¢é€Ÿè‡ªå‹•æ—‹è½‰
                scene.rotation.y += 0.005;
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, 0, 0.05);

            } else if (currentState === STATE.DISPERSED || currentState === STATE.ZOOM) {
                // æ•£é–‹/ç¸®æ”¾ç‹€æ…‹ï¼šæ‰‹å‹¢æ§åˆ¶æ—‹è½‰
                scene.rotation.y = THREE.MathUtils.lerp(scene.rotation.y, targetRotationY, 0.05);
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, targetRotationX, 0.05);
            }

            // 2. æ¼‚æµ®å‹•ç•«
            particles.forEach((p, i) => {
                if (currentState === STATE.DISPERSED && i !== zoomedParticleIndex) {
                    p.position.y += Math.sin(time * 0.001 + p.userData.id) * 0.02;
                    p.lookAt(camera.position);
                } else if (currentState === STATE.COALESCED || mediaPipeFailed) {
                    p.lookAt(0,0,0);
                }
            });

            // 3. æ°£çƒå’ŒèŠ±ç“£å‹•ç•« (çœç•¥ï¼Œèˆ‡ä¸Šæ¬¡ç›¸åŒ)
            if (balloonGroup) {
                balloonGroup.children.forEach(b => {
                    b.position.y += b.userData.speed;
                    b.position.x += Math.sin(time * 0.001 + b.position.y) * 0.02;
                    if (b.position.y > 30) { b.position.y = -30; b.position.x = (Math.random()-0.5)*40; }
                });
            }

            if (petalGroup) {
                petalGroup.children.forEach(p => {
                    p.position.y -= p.userData.fallSpeed;
                    p.rotation.x += p.userData.rotSpeed;
                    p.rotation.y += p.userData.rotSpeed;
                    p.position.x += Math.sin(time * 0.002 + p.position.y) * 0.05;
                    if (p.position.y < -30) { p.position.y = 30; p.position.x = (Math.random()-0.5)*50; }
                });
            }

            // 4. æ¨™èªç‰Œå‹•ç•« (è¼•å¾®æ¼‚æµ®)
            if (catSignMesh) {
                catSignMesh.position.y += Math.sin(time * 0.003) * 0.01;
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // é‹è¡Œ
        init();

    </script>
</body>
</html>

