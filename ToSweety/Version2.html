<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å°èƒ†å®è´ç”Ÿæ—¥å¿«ä¹ - ç²’å­äº‘</title>
    <style>
        /* å¯¼å…¥å¯çˆ±çš„ä¸­æ–‡å­—ä½“ï¼Œå¦‚ Ma Shan Zheng (é©¬å±±æ­£) æˆ–å…¶ä»–åœ†æ¶¦å­—ä½“ */
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #E6E6FA, #B0E0E6); /* æ·¡ç´« + å¥¶è“ */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .camera-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            transform: scaleX(-1); /* é•œåƒ */
            opacity: 0.7;
            transition: opacity 1s ease, border 1s ease;
            z-index: 20;
            background: #000;
        }

        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 240, 245, 1);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s ease;
            flex-direction: column;
        }
        
        .loading-text {
            color: #9370DB;
            font-size: 24px;
            font-weight: bold;
            margin-top: 20px;
        }

        /* ç°¡å–®çš„è¼‰å…¥å‹•ç•« */
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #E6E6FA;
            border-top: 5px solid #9370DB;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .control-panel {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 15px;
            color: #483D8B;
            max-width: 300px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 10px 0;
            text-shadow: 0 0 5px rgba(255,255,255,0.8);
        }

        .instructions {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .upload-btn {
            margin-top: 10px;
            background: linear-gradient(45deg, #FFB6C1, #9370DB);
            border: none;
            padding: 10px 20px;
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
            pointer-events: auto;
            display: inline-block;
        }

        .upload-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px #FFB6C1;
        }
        
        .status-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 20px;
            color: #6A5ACD;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 2px 10px rgba(147, 112, 219, 0.3);
            transition: background 0.5s, color 0.5s;
        }

        #file-input { display: none; }
    </style>
    <!-- Import Maps for Three.js and MediaPipe -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loading" class="loading-screen">
        <div class="spinner"></div>
        <div class="loading-text">æ­£åœ¨æº–å‚™ç”Ÿæ—¥é©šå–œ...</div>
        <div style="margin-top:10px; font-size: 0.8em; color: #666;">è«‹å…è¨±é¡é ­æ¬Šé™ä»¥é–‹å•Ÿé­”æ³•äº’å‹•</div>
    </div>

    <div id="ui-layer">
        <div class="control-panel">
            <h1>âœ¨ é­”æ³•æ‰‹å‹¢æ§åˆ¶ âœ¨</h1>
            <div id="instruction-text" class="instructions">
                âœŠ <b>æ¡æ‹³</b>ï¼šå‡èšå›æ†¶ (åˆæ”)<br>
                ğŸ– <b>å¼µé–‹æ‰‹</b>ï¼šé‡‹æ”¾å¿«æ¨‚ (æ•£é–‹)<br>
                ğŸ‘‹ <b>ç§»å‹•æ‰‹æŒ</b>ï¼šåœ¨æ•£é–‹æ™‚æ—‹è½‰è¦–è§’<br>
                ğŸ‘Œ <b>æåˆ</b>ï¼šæŠ“å–ä¸€å¼µç…§ç‰‡æ”¾å¤§
            </div>
            <!-- ä¿®æ”¹æŒ‰éˆ•æ–‡å­—ï¼Œå¼·èª¿å¯ä¸Šå‚³æ›´å¤šåœ–ç‰‡ -->
            <button class="upload-btn" onclick="document.getElementById('file-input').click()">â• ä¸Šå‚³æ›´å¤šç…§ç‰‡</button>
            <input type="file" id="file-input" multiple accept="image/*">
        </div>
        <div id="status-text" class="status-badge">ç­‰å¾…æ‰‹å‹¢...</div>
    </div>

    <video id="webcam" class="camera-feed" autoplay playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, GestureRecognizer } from '@mediapipe/tasks-vision';

        // --- é…ç½® ---
        const CONFIG = {
            particleCount: 250,
            scatterRadius: 30,
            sphereRadius: 8,
            colors: [0xFFB6C1, 0x9370DB, 0x87CEEB, 0xFFFFFF, 0xFF69B4],
            icons: ['ğŸ‚', 'ğŸ•¯ï¸', 'ğŸ¾', 'ğŸ€', 'ğŸ©'],
            catText: "å°è†½å¯¶è²ç”Ÿæ—¥å¿«æ¨‚"
        };
        const SIGN_POS_COALESCED = { y: 15, z: 5 };
        const SIGN_POS_DISPERSED = { y: 20, z: 8 };

        // ğŸ¯ é è¼‰å…¥åœ–ç‰‡è·¯å¾‘åˆ—è¡¨
        // ----------------------------------------------------------------------
        // ğŸš¨ é‡è¦ï¼šè«‹å°‡æ‚¨çš„åœ–ç‰‡ï¼ˆå¦‚ photo1.jpg, photo2.pngï¼‰æ”¾ç½®æ–¼ 'ToSweety' è³‡æ–™å¤¾å…§ã€‚
        // ----------------------------------------------------------------------
        const PRELOAD_IMAGE_PATHS = [
            'ToSweety/photo1.jpg', 
            'ToSweety/photo2.png',
            'ToSweety/photo3.gif', 
            // æ‚¨å¯ä»¥æ·»åŠ æ›´å¤šè·¯å¾‘ï¼Œä½†è«‹ç¢ºä¿æ–‡ä»¶å­˜åœ¨ä¸”è·¯å¾‘æ­£ç¢º
        ];

        // --- å…¨åŸŸç‹€æ…‹ ---
        let scene, camera, renderer, composer;
        let particles = [];
        let photoTextures = []; // å„²å­˜ç…§ç‰‡ç´‹ç†ï¼Œindex 0 ç‚ºé è¨­ä½”ä½åœ–
        let defaultTextures = []; // å„²å­˜è¡¨æƒ…ç¬¦è™Ÿç´‹ç†
        let balloonGroup, petalGroup;
        let catSignMesh;
        
        let gestureRecognizer;
        let videoElement = document.getElementById('webcam');
        let lastVideoTime = -1;
        let results = undefined;
        let mediaPipeFailed = false; 

        const STATE = {
            COALESCED: 'COALESCED',
            DISPERSED: 'DISPERSED',
            ZOOM: 'ZOOM'
        };
        let currentState = STATE.COALESCED;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let zoomedParticleIndex = -1;

        // --- åˆå§‹åŒ– ---

        async function init() {
            // 1. Three.js è¨­å®š
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xE6E6FA, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 40;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // ğŸ¯ ä¿®æ­£ 1ï¼šèª¿æ•´æ›å…‰åº¦ã€‚å°‡æ›å…‰å¾ 1.2 ç•¥å¾®é™ä½åˆ° 0.85ï¼Œä»¥æ¸›å°‘éæ›ã€‚
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.85; 

            container.appendChild(renderer.domElement);

            // å¾ŒæœŸè™•ç† (Bloom è¼å…‰)
            const renderScene = new RenderPass(scene, camera);
            // ğŸ¯ ä¿®æ­£ 1ï¼šé™ä½ Bloom çš„å¼·åº¦å’ŒåŠå¾‘ï¼Œä½¿å…¶æ›´æŸ”å’Œã€‚
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 
                0.8, // é™ä½å¼·åº¦ (Strength)
                0.4, 
                0.85
            );
            bloomPass.threshold = 0.1; 
            bloomPass.strength = 0.8; 
            bloomPass.radius = 0.3;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç‡ˆå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); 
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xFFB6C1, 1.5, 100); // ç•¥å¾®é™ä½é»å…‰æºå¼·åº¦
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // 2. è³‡æºç”Ÿæˆèˆ‡è¼‰å…¥
            generateTextures(); // ç”Ÿæˆé è¨­åœ–æ¨™å’Œåˆå§‹ä½”ä½åœ–
            await loadPreloadedImages(); // è¼‰å…¥é è¨­åœ–ç‰‡
            createParticles(); // å‰µå»ºç²’å­ï¼Œä½¿ç”¨å·²è¼‰å…¥æˆ–ä½”ä½ç´‹ç†
            createDecorations();
            createCatSign(); // ğŸ¯ ä¿®æ­£ 2ï¼šå°‡åœ¨è©²å‡½æ•¸ä¸­å¯¦ç¾å¸ƒå¶è²“å’Œç”Ÿæ—¥ç‰Œ

            // 3. MediaPipe è¨­å®š (éåŒæ­¥ï¼Œå¯èƒ½å¤±æ•—)
            await setupMediaPipe();

            // 4. ç›£è½å™¨
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            
            // 5. å•Ÿå‹•å¾ªç’°
            animate();
        }

        // --- è³‡æºç”Ÿæˆè¼”åŠ©å‡½å¼ ---
        function generateTextures() {
            CONFIG.icons.forEach(icon => {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.font = '80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText(icon, 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                defaultTextures.push(texture);
            });

            // åˆå§‹ç…§ç‰‡/ä¸Šå‚³æç¤ºåœ– (ä½œç‚º index 0 ä½”ä½ç¬¦)
            const pCanvas = document.createElement('canvas');
            pCanvas.width = 512;
            pCanvas.height = 512;
            const ctx = pCanvas.getContext('2d');
            ctx.fillStyle = '#1A1A1A'; 
            ctx.fillRect(0,0,512,512);
            ctx.fillStyle = '#333';
            ctx.fillRect(20,20,472,472); 
            ctx.fillStyle = '#AAA';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('é»æ“Šä¸‹æ–¹æŒ‰éˆ•ä¸Šå‚³ç…§ç‰‡', 256, 256);
            
            const pTexture = new THREE.CanvasTexture(pCanvas);
            photoTextures.push(pTexture);
        }

        async function loadPreloadedImages() {
            return new Promise(resolve => {
                const loader = new THREE.TextureLoader();
                let loadedCount = 0;
                
                if (PRELOAD_IMAGE_PATHS.length === 0) {
                    resolve();
                    return;
                }

                PRELOAD_IMAGE_PATHS.forEach(path => {
                    loader.load(
                        path,
                        (texture) => {
                            // è¼‰å…¥æˆåŠŸ
                            photoTextures.push(texture);
                            loadedCount++;
                            if (loadedCount === PRELOAD_IMAGE_PATHS.length) {
                                resolve();
                            }
                        },
                        undefined, // onProgress
                        (error) => {
                            // è¼‰å…¥å¤±æ•— (e.g., 404), ç¹¼çºŒè¼‰å…¥ä¸‹ä¸€å€‹
                            console.warn(`Failed to load preloaded image: ${path}. Error:`, error);
                            loadedCount++;
                            if (loadedCount === PRELOAD_IMAGE_PATHS.length) {
                                resolve();
                            }
                        }
                    );
                });
            });
        }

        function createParticles() {
            const geometry = new THREE.PlaneGeometry(2.5, 2.5); 
            const group = new THREE.Group();
            scene.add(group);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const isPhoto = Math.random() > 0.6;
                
                let material;
                if (isPhoto) {
                    const initialMap = photoTextures.length > 0 ? photoTextures[0] : defaultTextures[0];
                    // ğŸ¯ ä¿®æ­£ 1ï¼šå°‡ç…§ç‰‡æè³ªçš„åŸºç¤é¡è‰²èª¿æš—åˆ° 0x777777ï¼Œä»¥æ¸›å°‘è‡ªç™¼å…‰ï¼Œæé«˜åœ–ç‰‡å°æ¯”åº¦ã€‚
                    material = new THREE.MeshBasicMaterial({ 
                        map: initialMap, 
                        transparent: true,
                        side: THREE.DoubleSide,
                        depthWrite: false, 
                        color: 0x777777 
                    });
                } else {
                    const texIndex = Math.floor(Math.random() * defaultTextures.length);
                    material = new THREE.MeshBasicMaterial({ 
                        map: defaultTextures[texIndex], 
                        transparent: true,
                        color: CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)],
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                }

                const mesh = new THREE.Mesh(geometry, material);
                
                if (isPhoto) {
                    mesh.scale.set(1.5, 1.5, 1.5); // è®“ç…§ç‰‡ç²’å­æ›´å¤§
                }

                const phi = Math.acos(-1 + (2 * i) / CONFIG.particleCount);
                const theta = Math.sqrt(CONFIG.particleCount * Math.PI) * phi;
                
                const r = CONFIG.sphereRadius + (Math.random() - 0.5) * 2;
                const x = r * Math.cos(theta) * Math.sin(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(phi);

                mesh.position.set(x, y, z);
                mesh.lookAt(0,0,0);

                mesh.userData = {
                    originalPos: new THREE.Vector3(x, y, z),
                    scatterPos: new THREE.Vector3(
                        (Math.random() - 0.5) * CONFIG.scatterRadius * 2,
                        (Math.random() - 0.5) * CONFIG.scatterRadius * 1.5,
                        (Math.random() - 0.5) * CONFIG.scatterRadius * 1.5
                    ),
                    velocity: new THREE.Vector3(0, Math.random() * 0.02, 0),
                    rotationSpeed: new THREE.Vector3(Math.random()*0.01, Math.random()*0.01, 0),
                    isPhoto: isPhoto,
                    id: i
                };

                particles.push(mesh);
                group.add(mesh);
            }
            
            // åˆå§‹å‰µå»ºç²’å­å¾Œï¼Œç«‹å³æ‡‰ç”¨å·²è¼‰å…¥çš„ç…§ç‰‡
            updateParticlesWithPhotos();
        }

        // ğŸ¯ ä¿®æ­£ 2ï¼šé‡æ–°ç¹ªè£½å¸ƒå¶è²“å’Œå¯æ„›ç”Ÿæ—¥ç‰Œ
        function createCatSign() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // --- ç¹ªè£½å¸ƒå¶è²“ (Ragdoll Cat) ---
            ctx.save();
            ctx.translate(256, 180);

            // 1. é ­éƒ¨ (åç™½ï¼Œå¸ƒå¶è²“ç‰¹å¾µ)
            ctx.fillStyle = '#FFFFFF'; 
            ctx.beginPath(); 
            ctx.arc(0, 0, 100, 0, Math.PI * 2); 
            ctx.fill();
            
            // 2. ç‰¹å¾µè‰²å¡Š (æ£•è‰²/ç±³è‰²)
            ctx.fillStyle = '#A0522D'; 
            // è€³æœµ
            ctx.beginPath(); ctx.moveTo(-70, -100); ctx.lineTo(-110, -140); ctx.lineTo(-30, -100); ctx.fill();
            ctx.beginPath(); ctx.moveTo(70, -100); ctx.lineTo(110, -140); ctx.lineTo(30, -100); ctx.fill();
            // é¢éƒ¨ V å½¢è‰²å¡Š
            ctx.beginPath();
            ctx.moveTo(0, 50);
            ctx.bezierCurveTo(-50, 0, -100, -70, -60, -80);
            ctx.lineTo(60, -80);
            ctx.bezierCurveTo(100, -70, 50, 0, 0, 50);
            ctx.fill();

            // 3. è—çœ¼ç›
            ctx.fillStyle = '#ADD8E6'; // æ·ºè—è‰²
            ctx.beginPath(); ctx.arc(-35, -20, 18, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(35, -20, 18, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#00008B'; // æ·±è—è‰²ç³å­”
            ctx.beginPath(); ctx.arc(-35, -20, 6, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(35, -20, 6, 0, Math.PI*2); ctx.fill();
            
            // 4. é¼»å­å’Œå˜´å·´
            ctx.fillStyle = '#FFC0CB'; // ç²‰è‰²é¼»å­
            ctx.beginPath(); ctx.arc(0, 10, 10, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#333'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(0, 35); ctx.stroke(); // å˜´å·´ç·š
            
            ctx.restore();

            // --- ç¹ªè£½ç”Ÿæ—¥ç‰Œ ---
            ctx.save();
            ctx.translate(256, 380); // ç‰Œå­ä½ç½®åœ¨è²“çš„ä¸‹æ–¹

            // ç‰Œå­èƒŒæ™¯ (ç²‰è‰²é‚Šæ¡†ï¼Œç™½è‰²åº•)
            ctx.fillStyle = '#FFFFFF'; // ç™½è‰²åº•
            ctx.strokeStyle = '#FF69B4'; // ç²‰è‰²é‚Šæ¡†
            ctx.lineWidth = 10;
            ctx.beginPath(); 
            ctx.roundRect(-220, -60, 440, 120, 25);
            ctx.fill(); 
            ctx.stroke();

            // æ–‡æœ¬ (å¯æ„›é¢¨)
            ctx.fillStyle = '#FF69B4'; // ç²‰ç´…è‰²å¡«å……
            ctx.strokeStyle = '#C71585'; // æ·±ç²‰è‰²æé‚Š
            ctx.lineWidth = 4;
            // ğŸ¯ ä½¿ç”¨ Ma Shan Zheng å­—é«”ï¼Œå¦‚æœç„¡æ³•è¼‰å…¥å‰‡ä½¿ç”¨ Comic Sans MS ä½œç‚ºå‚™é¸
            ctx.font = 'bold 50px "Ma Shan Zheng", "Comic Sans MS", "Microsoft YaHei", sans-serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 5;
            
            ctx.strokeText(CONFIG.catText, 0, 0); 
            ctx.fillText(CONFIG.catText, 0, 0);

            ctx.restore();
            // --- ç¹ªè£½çµæŸ ---

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
            catSignMesh = new THREE.Sprite(material);
            catSignMesh.scale.set(18, 18, 1); // æ”¾å¤§å°ºå¯¸ï¼Œç¢ºä¿åœ¨ 3D ç©ºé–“ä¸­å¯è¦‹
            catSignMesh.position.set(0, SIGN_POS_COALESCED.y, SIGN_POS_COALESCED.z); 
            scene.add(catSignMesh);
        }


        function createDecorations() {
            // ... (ä¿æŒä¸è®Š)
            balloonGroup = new THREE.Group();
            const balloonGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const balloonMat = new THREE.MeshPhongMaterial({ 
                color: 0xFF69B4, shininess: 100, specular: 0xFFFFFF 
            });
            
            for(let i=0; i<15; i++) {
                const b = new THREE.Mesh(balloonGeo, balloonMat);
                b.position.set((Math.random()-0.5)*40, -20 + Math.random()*20, (Math.random()-0.5)*20);
                b.userData = { speed: 0.02 + Math.random()*0.03 };
                balloonGroup.add(b);
            }
            scene.add(balloonGroup);

            petalGroup = new THREE.Group();
            const petalGeo = new THREE.PlaneGeometry(0.5, 0.5); 
            const petalMat = new THREE.MeshBasicMaterial({ 
                color: 0xFFB7C5, side: THREE.DoubleSide, transparent: true, opacity: 0.8, depthWrite: false 
            });

            for(let i=0; i<100; i++) {
                const p = new THREE.Mesh(petalGeo, petalMat);
                p.position.set((Math.random()-0.5)*50, Math.random()*30, (Math.random()-0.5)*30);
                p.rotation.set(Math.random(), Math.random(), Math.random());
                p.userData = { 
                    fallSpeed: 0.02 + Math.random()*0.05,
                    rotSpeed: 0.02 + Math.random()*0.02
                };
                petalGroup.add(p);
            }
            scene.add(petalGroup);
        }

        function handleImageUpload(event) {
            const files = event.target.files;
            if (!files.length) return;

            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 512;
                        canvas.height = 512;
                        const ctx = canvas.getContext('2d');
                        
                        // ä½¿ç”¨æ·±è‰²èƒŒæ™¯ï¼Œç¢ºä¿ç…§ç‰‡åœ¨ç™¼å…‰ç’°å¢ƒä¸­å°æ¯”åº¦é«˜
                        ctx.fillStyle = '#111';
                        ctx.fillRect(0,0,512,512);
                        
                        const scale = Math.min(460/img.width, 460/img.height);
                        const w = img.width * scale;
                        const h = img.height * scale;
                        ctx.drawImage(img, (512-w)/2, (512-h)/2, w, h); // å±…ä¸­ç¹ªè£½
                        
                        const tex = new THREE.CanvasTexture(canvas);
                        photoTextures.push(tex);
                        
                        // é‡æ–°åˆ†é…ç´‹ç†ä»¥åŒ…å«æ–°ä¸Šå‚³çš„ç…§ç‰‡
                        updateParticlesWithPhotos();
                    };
                };
                reader.readAsDataURL(file);
            });
        }

        function updateParticlesWithPhotos() {
            // åªæœ‰ç•¶ photoTextures ä¸­æœ‰è‡³å°‘ 2 å€‹ç´‹ç†æ™‚ (1å€‹ä½”ä½ç¬¦ + 1å€‹å¯¦éš›åœ–ç‰‡) æ‰æ›¿æ›
            if (photoTextures.length <= 1) return;
            
            let texIndex = 1;
            particles.forEach(p => {
                if (p.userData.isPhoto) {
                    // å¾ index 1 é–‹å§‹å¾ªç’°ä½¿ç”¨å¯¦éš›ç…§ç‰‡ç´‹ç†
                    p.material.map = photoTextures[texIndex];
                    p.material.needsUpdate = true;
                    texIndex = (texIndex + 1) % photoTextures.length;
                    // å¦‚æœå›åˆ° photoTextures[0] (ä½”ä½ç¬¦)ï¼Œå‰‡è·³éä¸¦ä½¿ç”¨ photoTextures[1]
                    if (texIndex === 0) texIndex = 1; 
                }
            });
        }

        // --- MediaPipe é‚è¼¯ ---

        async function setupMediaPipe() {
            // ... (MediaPipe logic remains the same)
            const MODEL_PATH = 'gesture_recognizer.task'; 
            let stream;
            
            try {
                // 1. åˆå§‹åŒ–æ‰‹å‹¢è­˜åˆ¥å™¨
                document.getElementById('status-text').innerText = "è¼‰å…¥ AI æ¨¡å‹...";
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: MODEL_PATH, 
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                document.getElementById('status-text').innerText = "è«‹æ±‚é¡é ­æ¬Šé™...";

                // 2. å•Ÿå‹•é¡é ­
                const constraints = { video: { width: 320, height: 240 } };
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    document.getElementById('status-text').innerText = "å·²å°±ç·’ï¼Œè«‹ä¼¸å‡ºæ‰‹";
                    // ç§»é™¤è¼‰å…¥ç•«é¢
                    document.getElementById('loading').style.opacity = 0;
                    setTimeout(() => document.getElementById('loading').remove(), 1000);

                    // é–‹å§‹é æ¸¬å¾ªç’°
                    predictWebcam();
                };

            } catch (error) {
                console.error("MediaPipe or Camera setup failed:", error);
                
                let errorMessage = "åˆå§‹åŒ–å¤±æ•—ï¼šæ‰‹å‹¢äº’å‹•ç¦ç”¨ (å•Ÿç”¨è‡ªå‹•æ—‹è½‰)";
                let instructions = "<b>ğŸ‘‹ æ‰‹å‹¢äº’å‹•ç¦ç”¨ã€‚</b><br>æ­£åœ¨å•Ÿç”¨è‡ªå‹•æ—‹è½‰æ¨¡å¼ã€‚";
                
                // æª¢æŸ¥æ˜¯å¦æ˜¯æ¨¡å‹è¼‰å…¥å¤±æ•— (æœ€å¯èƒ½çš„åŸå› )
                if (error.message && error.message.includes('Failed to fetch')) {
                     errorMessage = `AI æ¨¡å‹è¼‰å…¥å¤±æ•—ã€‚è«‹ç¢ºèª ${MODEL_PATH} æª”æ¡ˆå·²ä¸Šå‚³è‡³åŒç›®éŒ„ã€‚`;
                     instructions = `<b>â— éŒ¯èª¤åŸå› ï¼š</b>AI æ¨¡å‹æª”æ¡ˆéºå¤±æˆ–è·¯å¾‘éŒ¯èª¤ã€‚è«‹ç¢ºèªã€Œ${MODEL_PATH}ã€æª”æ¡ˆèˆ‡ HTML æª”æ¡ˆåœ¨ GitHub å€‰åº«çš„**åŒä¸€ç›®éŒ„**ã€‚`;
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage = "é¡é ­æ¬Šé™è¢«æ‹’ã€‚æ‰‹å‹¢äº’å‹•ç¦ç”¨ (å•Ÿç”¨è‡ªå‹•æ—‹è½‰)ã€‚";
                    instructions = "<b>â— é¡é ­éŒ¯èª¤ï¼š</b>æ‚¨å¿…é ˆå…è¨±é¡é ­æ¬Šé™æ‰èƒ½ä½¿ç”¨æ‰‹å‹¢äº’å‹•ã€‚";
                } else if (error.name === 'NotFoundError') {
                    errorMessage = "æœªæ‰¾åˆ°é¡é ­è¨­å‚™ã€‚æ‰‹å‹¢äº’å‹•ç¦ç”¨ (å•Ÿç”¨è‡ªå‹•æ—‹è½‰)ã€‚";
                } 
                
                document.getElementById('status-text').innerText = errorMessage;
                document.getElementById('instruction-text').innerHTML = instructions;

                videoElement.style.opacity = 0.2; 
                videoElement.style.border = '2px solid red';
                
                mediaPipeFailed = true;
                
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => document.getElementById('loading').remove(), 1000);
            }
        }

        // --- (predictWebcam, processGestures, isPinching, changeState, animate, onWindowResize é‚è¼¯ä¿æŒä¸è®Š) ---
        
        async function predictWebcam() {
            if (mediaPipeFailed) return;

            if (lastVideoTime === -1) {
                 // é¦–æ¬¡æˆåŠŸè¼‰å…¥ï¼Œéš±è—è¦–è¨Šæºä¸¦æ”¹è®Šç‹€æ…‹æ–‡å­—é¡è‰²
                 videoElement.style.opacity = 0;
                 document.getElementById('status-text').style.background = 'rgba(147, 112, 219, 0.8)'; 
                 document.getElementById('status-text').style.color = 'white';
            }
            
            if (gestureRecognizer && videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                try {
                    results = gestureRecognizer.recognizeForVideo(videoElement, Date.now());
                    processGestures(results);
                } catch (e) {
                    console.warn("Gesture recognition skipped for this frame", e);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(results) {
            if (!results || !results.gestures || results.gestures.length === 0 || !results.landmarks || results.landmarks.length === 0) {
                document.getElementById('status-text').innerText = "æœªæª¢æ¸¬åˆ°æ‰‹";
                return;
            }

            const gesturesList = results.gestures[0];
            const landmarksList = results.landmarks[0];
            
            if (!gesturesList || gesturesList.length === 0 || !landmarksList) {
                document.getElementById('status-text').innerText = "æª¢æ¸¬ä¸­...";
                return;
            }

            const gesture = gesturesList[0].categoryName;
            const landmarks = landmarksList;
            
            let status = "ç­‰å¾…...";

            if (gesture === 'Closed_Fist') {
                status = "å‹•ä½œ: èšåˆ (æ¡æ‹³)";
                changeState(STATE.COALESCED);
            } else if (gesture === 'Open_Palm') {
                status = "å‹•ä½œ: æ•£é–‹ (å¼µæ‰‹)";
                changeState(STATE.DISPERSED);
            } else if (gesture === 'Victory' || isPinching(landmarks)) {
                if (currentState === STATE.DISPERSED) {
                    status = "å‹•ä½œ: æŠ“å–ç…§ç‰‡ (æåˆ)";
                    if (currentState !== STATE.ZOOM) {
                        changeState(STATE.ZOOM);
                    }
                }
            }
            
            if (currentState === STATE.DISPERSED && gesture !== 'Closed_Fist') {
                if (landmarks[0]) {
                    const x = landmarks[0].x;
                    const y = landmarks[0].y;
                    
                    targetRotationY = (x - 0.5) * 4;
                    targetRotationX = (y - 0.5) * 2;
                    status += " | æ—‹è½‰ä¸­";
                }
            }

            document.getElementById('status-text').innerText = status;
        }

        function isPinching(landmarks) {
            if (!landmarks[4] || !landmarks[8]) return false;
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            return dist < 0.05; 
        }

        function changeState(newState) {
            if (currentState === newState) return;
            
            // å¦‚æœæ˜¯å¾ ZOOM ç‹€æ…‹åˆ‡æ›ï¼Œéœ€è¦å°‡è¢«æ”¾å¤§çš„ç²’å­é‚„åŸ
            if (currentState === STATE.ZOOM && zoomedParticleIndex !== -1) {
                const p = particles[zoomedParticleIndex];
                // é‚„åŸå¤§å°
                new TWEEN.Tween(p.scale).to({ x: p.userData.isPhoto ? 1.5 : 1, y: p.userData.isPhoto ? 1.5 : 1, z: p.userData.isPhoto ? 1.5 : 1 }, 500).start();
                
                // é‚„åŸå…¶ä»–ç²’å­çš„ Z è»¸
                particles.forEach(p => {
                    new TWEEN.Tween(p.position.z).to(currentState === STATE.COALESCED ? p.userData.originalPos.z : p.userData.scatterPos.z, 500).start();
                });

                zoomedParticleIndex = -1;
            }

            currentState = newState;

            if (newState === STATE.COALESCED) {
                particles.forEach(p => {
                    new TWEEN.Tween(p.position).to(p.userData.originalPos, 1500).easing(TWEEN.Easing.Elastic.Out).start();
                    new TWEEN.Tween(p.rotation).to({ x: 0, y: 0, z: 0 }, 1500).onUpdate(() => p.lookAt(0,0,0)).start();
                });
                new TWEEN.Tween(catSignMesh.position).to(SIGN_POS_COALESCED, 1000).start();

            } else if (newState === STATE.DISPERSED) {
                particles.forEach(p => {
                    new TWEEN.Tween(p.position).to(p.userData.scatterPos, 1500).easing(TWEEN.Easing.Back.Out).start();
                    new TWEEN.Tween(p.rotation).to({ x: camera.rotation.x, y: camera.rotation.y, z: 0 }, 1000).onUpdate(() => p.lookAt(camera.position)).start();
                });
                new TWEEN.Tween(catSignMesh.position).to(SIGN_POS_DISPERSED, 1000).start();

            } else if (newState === STATE.ZOOM) {
                // ç¢ºä¿æœ‰å¯¦éš›ç…§ç‰‡å¯æ”¾å¤§ï¼ˆæ’é™¤ä½”ä½ç¬¦ï¼‰
                const photoParticles = particles.filter(p => p.userData.isPhoto);
                // åªæœ‰ç•¶ actual photo textures > 0 æ™‚æ‰é€²è¡Œç¸®æ”¾
                if (photoTextures.length > 1 && photoParticles.length > 0) { 
                    const target = photoParticles[Math.floor(Math.random() * photoParticles.length)];
                    zoomedParticleIndex = particles.indexOf(target);

                    new TWEEN.Tween(target.position).to({ x: 0, y: 0, z: 25 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
                    new TWEEN.Tween(target.scale).to({ x: 5, y: 5, z: 5 }, 1000).start();
                    
                    particles.forEach(p => {
                        if (p !== target) {
                            // å°‡éç›®æ¨™ç²’å­æ¨é ä¸€é»
                            new TWEEN.Tween(p.position.z).to(p.userData.scatterPos.z - 5, 1000).start();
                        }
                    });
                } else {
                    // å¦‚æœæ²’æœ‰ç…§ç‰‡å¯æ”¾å¤§ï¼Œè‡ªå‹•è¿”å›æ•£é–‹ç‹€æ…‹ã€‚
                    currentState = STATE.DISPERSED; 
                }
            }
        }

        // --- ä¸»å¾ªç’° ---

        const clock = new THREE.Clock();

        function animate(time) {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            TWEEN.update(time);

            // 1. å ´æ™¯æ—‹è½‰é‚è¼¯
            if (mediaPipeFailed) {
                // å¦‚æœ MediaPipe å¤±æ•—ï¼Œå‰‡å•Ÿç”¨è‡ªå‹•æ—‹è½‰ï¼ˆå„ªé›…é™ç´šï¼‰
                scene.rotation.y += 0.003;
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, Math.sin(time * 0.0001) * 0.1, 0.05);

            } else if (currentState === STATE.COALESCED) {
                // èšåˆç‹€æ…‹ï¼šæ…¢é€Ÿè‡ªå‹•æ—‹è½‰
                scene.rotation.y += 0.005;
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, 0, 0.05);

            } else if (currentState === STATE.DISPERSED || currentState === STATE.ZOOM) {
                // æ•£é–‹/ç¸®æ”¾ç‹€æ…‹ï¼šæ‰‹å‹¢æ§åˆ¶æ—‹è½‰
                scene.rotation.y = THREE.MathUtils.lerp(scene.rotation.y, targetRotationY, 0.05);
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, targetRotationX, 0.05);
            }

            // 2. æ¼‚æµ®å‹•ç•«
            particles.forEach((p, i) => {
                if (currentState === STATE.DISPERSED && i !== zoomedParticleIndex) {
                    p.position.y += Math.sin(time * 0.001 + p.userData.id) * 0.02;
                    p.lookAt(camera.position);
                } else if (currentState === STATE.COALESCED || mediaPipeFailed) {
                    p.lookAt(0,0,0);
                }
            });

            // 3. æ°£çƒå’ŒèŠ±ç“£å‹•ç•« 
            if (balloonGroup) {
                balloonGroup.children.forEach(b => {
                    b.position.y += b.userData.speed;
                    b.position.x += Math.sin(time * 0.001 + b.position.y) * 0.02;
                    if (b.position.y > 30) { b.position.y = -30; b.position.x = (Math.random()-0.5)*40; }
                });
            }

            if (petalGroup) {
                petalGroup.children.forEach(p => {
                    p.position.y -= p.userData.fallSpeed;
                    p.rotation.x += p.userData.rotSpeed;
                    p.rotation.y += p.userData.rotSpeed;
                    p.position.x += Math.sin(time * 0.002 + p.position.y) * 0.05;
                    if (p.position.y < -30) { p.position.y = 30; p.position.x = (Math.random()-0.5)*50; }
                });
            }

            // 4. æ¨™èªç‰Œå‹•ç•« (è¼•å¾®æ¼‚æµ®)
            if (catSignMesh) {
                catSignMesh.position.y += Math.sin(time * 0.003) * 0.01;
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // é‹è¡Œ
        init();

    </script>
</body>
</html>